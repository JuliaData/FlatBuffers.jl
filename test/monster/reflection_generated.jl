# Code generated by the FlatBuffers compiler. DO NOT EDIT.

module Foo

using FlatBuffers

FlatBuffers.@scopedenum BaseType::Int8 None=0 UType=1 Bool=2 Byte=3 UByte=4 Short=5 UShort=6 Int=7 UInt=8 Long=9 ULong=10 Float=11 Double=12 String=13 Vector=14 Obj=15 Union=16 Array=17 MaxBaseType=18 

FlatBuffers.@scopedenum AdvancedFeatures::UInt64 AdvancedArrayFeatures=1 AdvancedUnionFeatures=2 OptionalScalars=4 DefaultVectorsAndStrings=8 

struct Type  <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::Type) = (
	:baseType,
	:element,
	:index,
	:fixedLength,
)

function Base.getproperty(x::Type, field::Symbol)
	if field === :baseType
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 4)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), BaseType)
		return BaseType(0)
	elseif field === :element
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), BaseType)
		return BaseType(0)
	elseif field === :index
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int32)
		return Int32(-1)
	elseif field === :fixedLength
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), UInt16)
		return UInt16(0)
	end
	return nothing
end

module TypeProperties
abstract type AbstractProperty end
struct baseType <: AbstractProperty end
struct element <: AbstractProperty end
struct index <: AbstractProperty end
struct fixedLength <: AbstractProperty end
end

function Base.getindex(x::Type, ::Type{TypeProperties.baseType})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 4)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), BaseType)
		return BaseType(0)
end

function Base.getindex(x::Type, ::Type{TypeProperties.element})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), BaseType)
		return BaseType(0)
end

function Base.getindex(x::Type, ::Type{TypeProperties.index})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int32)
		return Int32(-1)
end

function Base.getindex(x::Type, ::Type{TypeProperties.fixedLength})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), UInt16)
		return UInt16(0)
end


TypeStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 4)
TypeAddBaseType(b::FlatBuffers.Builder, baseType::BaseType) = FlatBuffers.prependslot!(b, 0, baseType, 0)
TypeAddElement(b::FlatBuffers.Builder, element::BaseType) = FlatBuffers.prependslot!(b, 1, element, 0)
TypeAddIndex(b::FlatBuffers.Builder, index::Int32) = FlatBuffers.prependslot!(b, 2, index, -1)
TypeAddFixedLength(b::FlatBuffers.Builder, fixedLength::UInt16) = FlatBuffers.prependslot!(b, 3, fixedLength, 0)
TypeEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct KeyValue <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::KeyValue) = (
	:key,
	:value,
)

function Base.getproperty(x::KeyValue, field::Symbol)
	if field === :key
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :value
		#GetStringField
		o = FlatBuffers.offset(x, 6)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	end
	return nothing
end

module KeyValueProperties
abstract type AbstractProperty end
struct key <: AbstractProperty end
struct value <: AbstractProperty end
end

function Base.getindex(x::KeyValue, ::Type{KeyValueProperties.key})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::KeyValue, ::Type{KeyValueProperties.value})
		#GetStringField
		o = FlatBuffers.offset(x, 6)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end


KeyValueStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 2)
KeyValueAddKey(b::FlatBuffers.Builder, key::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, key, 0)
KeyValueAddValue(b::FlatBuffers.Builder, value::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, value, 0)
KeyValueEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct EnumVal <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::EnumVal) = (
	:name,
	:value,
	:unionType,
	:documentation,
)

function Base.getproperty(x::EnumVal, field::Symbol)
	if field === :name
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :value
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int64)
		return Int64(0)
	elseif field === :unionType
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 10)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Type, FlatBuffers.bytes(x), y)
		end
	elseif field === :documentation
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	end
	return nothing
end

module EnumValProperties
abstract type AbstractProperty end
struct name <: AbstractProperty end
struct value <: AbstractProperty end
struct unionType <: AbstractProperty end
struct documentation <: AbstractProperty end
end

function Base.getindex(x::EnumVal, ::Type{EnumValProperties.name})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::EnumVal, ::Type{EnumValProperties.value})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int64)
		return Int64(0)
end

function Base.getindex(x::EnumVal, ::Type{EnumValProperties.unionType})
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 10)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Type, FlatBuffers.bytes(x), y)
		end
		return nothing
end

function Base.getindex(x::EnumVal, ::Type{EnumValProperties.documentation})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end


EnumValStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 5)
EnumValAddName(b::FlatBuffers.Builder, name::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, name, 0)
EnumValAddValue(b::FlatBuffers.Builder, value::Int64) = FlatBuffers.prependslot!(b, 1, value, 0)
EnumValAddUnionType(b::FlatBuffers.Builder, unionType::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 3, unionType, 0)
EnumValAddDocumentation(b::FlatBuffers.Builder, documentation::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 4, documentation, 0)
EnumValStartDocumentationVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
EnumValEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct Enum <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::Enum) = (
	:name,
	:values,
	:isUnion,
	:underlyingType,
	:attributes,
	:documentation,
	:declarationFile,
)

function Base.getproperty(x::Enum, field::Symbol)
	if field === :name
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :values
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{EnumVal}(x, o)
	elseif field === :isUnion
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
	elseif field === :underlyingType
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 10)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Type, FlatBuffers.bytes(x), y)
		end
	elseif field === :attributes
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
	elseif field === :documentation
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	elseif field === :declarationFile
		#GetStringField
		o = FlatBuffers.offset(x, 16)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	end
	return nothing
end

module EnumProperties
abstract type AbstractProperty end
struct name <: AbstractProperty end
struct values <: AbstractProperty end
struct isUnion <: AbstractProperty end
struct underlyingType <: AbstractProperty end
struct attributes <: AbstractProperty end
struct documentation <: AbstractProperty end
struct declarationFile <: AbstractProperty end
end

function Base.getindex(x::Enum, ::Type{EnumProperties.name})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::Enum, ::Type{EnumProperties.values})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{EnumVal}(x, o)
		return nothing
end

function Base.getindex(x::Enum, ::Type{EnumProperties.isUnion})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
end

function Base.getindex(x::Enum, ::Type{EnumProperties.underlyingType})
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 10)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Type, FlatBuffers.bytes(x), y)
		end
		return nothing
end

function Base.getindex(x::Enum, ::Type{EnumProperties.attributes})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
		return nothing
end

function Base.getindex(x::Enum, ::Type{EnumProperties.documentation})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end

function Base.getindex(x::Enum, ::Type{EnumProperties.declarationFile})
		#GetStringField
		o = FlatBuffers.offset(x, 16)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end


EnumStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 7)
EnumAddName(b::FlatBuffers.Builder, name::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, name, 0)
EnumAddValues(b::FlatBuffers.Builder, values::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, values, 0)
EnumStartValuesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
EnumAddIsUnion(b::FlatBuffers.Builder, isUnion::Bool) = FlatBuffers.prependslot!(b, 2, isUnion, false)
EnumAddUnderlyingType(b::FlatBuffers.Builder, underlyingType::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 3, underlyingType, 0)
EnumAddAttributes(b::FlatBuffers.Builder, attributes::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 4, attributes, 0)
EnumStartAttributesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
EnumAddDocumentation(b::FlatBuffers.Builder, documentation::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 5, documentation, 0)
EnumStartDocumentationVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
EnumAddDeclarationFile(b::FlatBuffers.Builder, declarationFile::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 6, declarationFile, 0)
EnumEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct Field <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::Field) = (
	:name,
	:type,
	:id,
	:offset,
	:defaultInteger,
	:defaultReal,
	:deprecated,
	:required,
	:key,
	:attributes,
	:documentation,
	:optional,
)

function Base.getproperty(x::Field, field::Symbol)
	if field === :name
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :type
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 6)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Type, FlatBuffers.bytes(x), y)
		end
	elseif field === :id
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), UInt16)
		return UInt16(0)
	elseif field === :offset
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), UInt16)
		return UInt16(0)
	elseif field === :defaultInteger
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int64)
		return Int64(0)
	elseif field === :defaultReal
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Float64)
		return Float64(0.0)
	elseif field === :deprecated
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 16)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
	elseif field === :required
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 18)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
	elseif field === :key
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 20)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
	elseif field === :attributes
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 22)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
	elseif field === :documentation
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 24)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	elseif field === :optional
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 26)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
	end
	return nothing
end

module FieldProperties
abstract type AbstractProperty end
struct name <: AbstractProperty end
struct type <: AbstractProperty end
struct id <: AbstractProperty end
struct offset <: AbstractProperty end
struct defaultInteger <: AbstractProperty end
struct defaultReal <: AbstractProperty end
struct deprecated <: AbstractProperty end
struct required <: AbstractProperty end
struct key <: AbstractProperty end
struct attributes <: AbstractProperty end
struct documentation <: AbstractProperty end
struct optional <: AbstractProperty end
end

function Base.getindex(x::Field, ::Type{FieldProperties.name})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::Field, ::Type{FieldProperties.type})
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 6)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Type, FlatBuffers.bytes(x), y)
		end
		return nothing
end

function Base.getindex(x::Field, ::Type{FieldProperties.id})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), UInt16)
		return UInt16(0)
end

function Base.getindex(x::Field, ::Type{FieldProperties.offset})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), UInt16)
		return UInt16(0)
end

function Base.getindex(x::Field, ::Type{FieldProperties.defaultInteger})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int64)
		return Int64(0)
end

function Base.getindex(x::Field, ::Type{FieldProperties.defaultReal})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Float64)
		return Float64(0.0)
end

function Base.getindex(x::Field, ::Type{FieldProperties.deprecated})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 16)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
end

function Base.getindex(x::Field, ::Type{FieldProperties.required})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 18)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
end

function Base.getindex(x::Field, ::Type{FieldProperties.key})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 20)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
end

function Base.getindex(x::Field, ::Type{FieldProperties.attributes})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 22)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
		return nothing
end

function Base.getindex(x::Field, ::Type{FieldProperties.documentation})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 24)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end

function Base.getindex(x::Field, ::Type{FieldProperties.optional})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 26)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
end


FieldStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 12)
FieldAddName(b::FlatBuffers.Builder, name::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, name, 0)
FieldAddType(b::FlatBuffers.Builder, type::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, type, 0)
FieldAddId(b::FlatBuffers.Builder, id::UInt16) = FlatBuffers.prependslot!(b, 2, id, 0)
FieldAddOffset(b::FlatBuffers.Builder, offset::UInt16) = FlatBuffers.prependslot!(b, 3, offset, 0)
FieldAddDefaultInteger(b::FlatBuffers.Builder, defaultInteger::Int64) = FlatBuffers.prependslot!(b, 4, defaultInteger, 0)
FieldAddDefaultReal(b::FlatBuffers.Builder, defaultReal::Float64) = FlatBuffers.prependslot!(b, 5, defaultReal, 0.0)
FieldAddDeprecated(b::FlatBuffers.Builder, deprecated::Bool) = FlatBuffers.prependslot!(b, 6, deprecated, false)
FieldAddRequired(b::FlatBuffers.Builder, required::Bool) = FlatBuffers.prependslot!(b, 7, required, false)
FieldAddKey(b::FlatBuffers.Builder, key::Bool) = FlatBuffers.prependslot!(b, 8, key, false)
FieldAddAttributes(b::FlatBuffers.Builder, attributes::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 9, attributes, 0)
FieldStartAttributesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
FieldAddDocumentation(b::FlatBuffers.Builder, documentation::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 10, documentation, 0)
FieldStartDocumentationVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
FieldAddOptional(b::FlatBuffers.Builder, optional::Bool) = FlatBuffers.prependslot!(b, 11, optional, false)
FieldEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct Object <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::Object) = (
	:name,
	:fields,
	:isStruct,
	:minalign,
	:bytesize,
	:attributes,
	:documentation,
	:declarationFile,
)

function Base.getproperty(x::Object, field::Symbol)
	if field === :name
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :fields
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{Field}(x, o)
	elseif field === :isStruct
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
	elseif field === :minalign
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int32)
		return Int32(0)
	elseif field === :bytesize
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int32)
		return Int32(0)
	elseif field === :attributes
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
	elseif field === :documentation
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 16)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	elseif field === :declarationFile
		#GetStringField
		o = FlatBuffers.offset(x, 18)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	end
	return nothing
end

module ObjectProperties
abstract type AbstractProperty end
struct name <: AbstractProperty end
struct fields <: AbstractProperty end
struct isStruct <: AbstractProperty end
struct minalign <: AbstractProperty end
struct bytesize <: AbstractProperty end
struct attributes <: AbstractProperty end
struct documentation <: AbstractProperty end
struct declarationFile <: AbstractProperty end
end

function Base.getindex(x::Object, ::Type{ObjectProperties.name})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::Object, ::Type{ObjectProperties.fields})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{Field}(x, o)
		return nothing
end

function Base.getindex(x::Object, ::Type{ObjectProperties.isStruct})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Bool)
		return Bool(false)
end

function Base.getindex(x::Object, ::Type{ObjectProperties.minalign})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int32)
		return Int32(0)
end

function Base.getindex(x::Object, ::Type{ObjectProperties.bytesize})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), Int32)
		return Int32(0)
end

function Base.getindex(x::Object, ::Type{ObjectProperties.attributes})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
		return nothing
end

function Base.getindex(x::Object, ::Type{ObjectProperties.documentation})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 16)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end

function Base.getindex(x::Object, ::Type{ObjectProperties.declarationFile})
		#GetStringField
		o = FlatBuffers.offset(x, 18)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end


ObjectStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 8)
ObjectAddName(b::FlatBuffers.Builder, name::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, name, 0)
ObjectAddFields(b::FlatBuffers.Builder, fields::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, fields, 0)
ObjectStartFieldsVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
ObjectAddIsStruct(b::FlatBuffers.Builder, isStruct::Bool) = FlatBuffers.prependslot!(b, 2, isStruct, false)
ObjectAddMinalign(b::FlatBuffers.Builder, minalign::Int32) = FlatBuffers.prependslot!(b, 3, minalign, 0)
ObjectAddBytesize(b::FlatBuffers.Builder, bytesize::Int32) = FlatBuffers.prependslot!(b, 4, bytesize, 0)
ObjectAddAttributes(b::FlatBuffers.Builder, attributes::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 5, attributes, 0)
ObjectStartAttributesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
ObjectAddDocumentation(b::FlatBuffers.Builder, documentation::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 6, documentation, 0)
ObjectStartDocumentationVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
ObjectAddDeclarationFile(b::FlatBuffers.Builder, declarationFile::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 7, declarationFile, 0)
ObjectEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct RPCCall <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::RPCCall) = (
	:name,
	:request,
	:response,
	:attributes,
	:documentation,
)

function Base.getproperty(x::RPCCall, field::Symbol)
	if field === :name
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :request
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 6)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Object, FlatBuffers.bytes(x), y)
		end
	elseif field === :response
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 8)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Object, FlatBuffers.bytes(x), y)
		end
	elseif field === :attributes
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
	elseif field === :documentation
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	end
	return nothing
end

module RPCCallProperties
abstract type AbstractProperty end
struct name <: AbstractProperty end
struct request <: AbstractProperty end
struct response <: AbstractProperty end
struct attributes <: AbstractProperty end
struct documentation <: AbstractProperty end
end

function Base.getindex(x::RPCCall, ::Type{RPCCallProperties.name})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::RPCCall, ::Type{RPCCallProperties.request})
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 6)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Object, FlatBuffers.bytes(x), y)
		end
		return nothing
end

function Base.getindex(x::RPCCall, ::Type{RPCCallProperties.response})
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 8)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Object, FlatBuffers.bytes(x), y)
		end
		return nothing
end

function Base.getindex(x::RPCCall, ::Type{RPCCallProperties.attributes})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
		return nothing
end

function Base.getindex(x::RPCCall, ::Type{RPCCallProperties.documentation})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 12)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end


RPCCallStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 5)
RPCCallAddName(b::FlatBuffers.Builder, name::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, name, 0)
RPCCallAddRequest(b::FlatBuffers.Builder, request::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, request, 0)
RPCCallAddResponse(b::FlatBuffers.Builder, response::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 2, response, 0)
RPCCallAddAttributes(b::FlatBuffers.Builder, attributes::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 3, attributes, 0)
RPCCallStartAttributesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
RPCCallAddDocumentation(b::FlatBuffers.Builder, documentation::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 4, documentation, 0)
RPCCallStartDocumentationVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
RPCCallEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct Service <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::Service) = (
	:name,
	:calls,
	:attributes,
	:documentation,
	:declarationFile,
)

function Base.getproperty(x::Service, field::Symbol)
	if field === :name
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :calls
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{RPCCall}(x, o)
	elseif field === :attributes
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
	elseif field === :documentation
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	elseif field === :declarationFile
		#GetStringField
		o = FlatBuffers.offset(x, 12)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	end
	return nothing
end

module ServiceProperties
abstract type AbstractProperty end
struct name <: AbstractProperty end
struct calls <: AbstractProperty end
struct attributes <: AbstractProperty end
struct documentation <: AbstractProperty end
struct declarationFile <: AbstractProperty end
end

function Base.getindex(x::Service, ::Type{ServiceProperties.name})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::Service, ::Type{ServiceProperties.calls})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{RPCCall}(x, o)
		return nothing
end

function Base.getindex(x::Service, ::Type{ServiceProperties.attributes})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 8)
		o != 0 && return FlatBuffers.Array{KeyValue}(x, o)
		return nothing
end

function Base.getindex(x::Service, ::Type{ServiceProperties.documentation})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 10)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end

function Base.getindex(x::Service, ::Type{ServiceProperties.declarationFile})
		#GetStringField
		o = FlatBuffers.offset(x, 12)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end


ServiceStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 5)
ServiceAddName(b::FlatBuffers.Builder, name::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, name, 0)
ServiceAddCalls(b::FlatBuffers.Builder, calls::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, calls, 0)
ServiceStartCallsVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
ServiceAddAttributes(b::FlatBuffers.Builder, attributes::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 2, attributes, 0)
ServiceStartAttributesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
ServiceAddDocumentation(b::FlatBuffers.Builder, documentation::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 3, documentation, 0)
ServiceStartDocumentationVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
ServiceAddDeclarationFile(b::FlatBuffers.Builder, declarationFile::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 4, declarationFile, 0)
ServiceEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

## /// File specific information.
## /// Symbols declared within a file may be recovered by iterating over all
## /// symbols and examining the `declaration_file` field.
struct SchemaFile <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::SchemaFile) = (
	:filename,
	:includedFilenames,
)

function Base.getproperty(x::SchemaFile, field::Symbol)
	if field === :filename
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :includedFilenames
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
	end
	return nothing
end

module SchemaFileProperties
abstract type AbstractProperty end
struct filename <: AbstractProperty end
struct includedFilenames <: AbstractProperty end
end

function Base.getindex(x::SchemaFile, ::Type{SchemaFileProperties.filename})
		#GetStringField
		o = FlatBuffers.offset(x, 4)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::SchemaFile, ::Type{SchemaFileProperties.includedFilenames})
		#GetMemberOfVectorOfNonStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{[]byte}(x, o)
		return nothing
end


SchemaFileStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 2)
SchemaFileAddFilename(b::FlatBuffers.Builder, filename::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, filename, 0)
SchemaFileAddIncludedFilenames(b::FlatBuffers.Builder, includedFilenames::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, includedFilenames, 0)
SchemaFileStartIncludedFilenamesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
SchemaFileEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)

struct Schema <: FlatBuffers.Table
	bytes::Vector{UInt8}
	pos::Base.Int
end

Base.propertynames(::Schema) = (
	:objects,
	:enums,
	:fileIdent,
	:fileExt,
	:rootTable,
	:services,
	:advancedFeatures,
	:fbsFiles,
)

function Base.getproperty(x::Schema, field::Symbol)
	if field === :objects
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 4)
		o != 0 && return FlatBuffers.Array{Object}(x, o)
	elseif field === :enums
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{Enum}(x, o)
	elseif field === :fileIdent
		#GetStringField
		o = FlatBuffers.offset(x, 8)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :fileExt
		#GetStringField
		o = FlatBuffers.offset(x, 10)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
	elseif field === :rootTable
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 12)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Object, FlatBuffers.bytes(x), y)
		end
	elseif field === :services
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.Array{Service}(x, o)
	elseif field === :advancedFeatures
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 16)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), AdvancedFeatures)
		return AdvancedFeatures(0)
	elseif field === :fbsFiles
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 18)
		o != 0 && return FlatBuffers.Array{SchemaFile}(x, o)
	end
	return nothing
end

module SchemaProperties
abstract type AbstractProperty end
struct objects <: AbstractProperty end
struct enums <: AbstractProperty end
struct fileIdent <: AbstractProperty end
struct fileExt <: AbstractProperty end
struct rootTable <: AbstractProperty end
struct services <: AbstractProperty end
struct advancedFeatures <: AbstractProperty end
struct fbsFiles <: AbstractProperty end
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.objects})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 4)
		o != 0 && return FlatBuffers.Array{Object}(x, o)
		return nothing
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.enums})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 6)
		o != 0 && return FlatBuffers.Array{Enum}(x, o)
		return nothing
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.fileIdent})
		#GetStringField
		o = FlatBuffers.offset(x, 8)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.fileExt})
		#GetStringField
		o = FlatBuffers.offset(x, 10)
		o != 0 && return String(x, o + FlatBuffers.pos(x))
		return string(0)
		return nothing
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.rootTable})
		#GetStructFieldOfTable
		o = FlatBuffers.offset(x, 12)
		if o != 0
			y = FlatBuffers.indirect(x, o + FlatBuffers.pos(x))
			return FlatBuffers.init(Object, FlatBuffers.bytes(x), y)
		end
		return nothing
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.services})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 14)
		o != 0 && return FlatBuffers.Array{Service}(x, o)
		return nothing
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.advancedFeatures})
		#GetScalarFieldOfTable
		o = FlatBuffers.offset(x, 16)
		o != 0 && return FlatBuffers.get(x, o + FlatBuffers.pos(x), AdvancedFeatures)
		return AdvancedFeatures(0)
end

function Base.getindex(x::Schema, ::Type{SchemaProperties.fbsFiles})
		#GetMemberOfVectorOfStruct
		o = FlatBuffers.offset(x, 18)
		o != 0 && return FlatBuffers.Array{SchemaFile}(x, o)
		return nothing
end


SchemaStart(b::FlatBuffers.Builder) = FlatBuffers.startobject!(b, 8)
SchemaAddObjects(b::FlatBuffers.Builder, objects::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 0, objects, 0)
SchemaStartObjectsVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
SchemaAddEnums(b::FlatBuffers.Builder, enums::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 1, enums, 0)
SchemaStartEnumsVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
SchemaAddFileIdent(b::FlatBuffers.Builder, fileIdent::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 2, fileIdent, 0)
SchemaAddFileExt(b::FlatBuffers.Builder, fileExt::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 3, fileExt, 0)
SchemaAddRootTable(b::FlatBuffers.Builder, rootTable::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 4, rootTable, 0)
SchemaAddServices(b::FlatBuffers.Builder, services::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 5, services, 0)
SchemaStartServicesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
SchemaAddAdvancedFeatures(b::FlatBuffers.Builder, advancedFeatures::AdvancedFeatures) = FlatBuffers.prependslot!(b, 6, advancedFeatures, 0)
SchemaAddFbsFiles(b::FlatBuffers.Builder, fbsFiles::FlatBuffers.UOffsetT) = FlatBuffers.prependoffsetslot!(b, 7, fbsFiles, 0)
SchemaStartFbsFilesVector(b::FlatBuffers.Builder, numelems::Integer) = FlatBuffers.startvector!(b, 4, numelems, 4)
SchemaEnd(b::FlatBuffers.Builder) = FlatBuffers.endobject!(b)



end #module

