<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FlatBuffers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FlatBuffers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/FlatBuffers.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="FlatBuffers.jl-Documentation-1" href="#FlatBuffers.jl-Documentation-1">FlatBuffers.jl Documentation</a></h1><h4><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h4><p>FlatBuffers.jl provides native Julia support for reading and writing binary structures following the google flatbuffer schema (see <a href="https://google.github.io/flatbuffers/flatbuffers_internals.html">here</a> for a more in-depth review of the binary format).</p><p>The typical language support for flatbuffers involves utilizing the <code>flatc</code> compiler to translate a flatbuffer schema file (.fbs) into a langugage-specific set of types/classes and methods. See <a href="https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html">here</a> for the official guide on writing schemas.</p><p>This Julia package provides the serialization primitives used by code that has been generated by <code>flatc</code>. Since it was originally built without <code>flatc</code> support, it can also be used as a minimal set of macros to provide flatbuffer-compatible serialization of existing Julia types. This has led to the Julia code generated by <code>flatc</code> appearing somewhat more readable than for other languages.</p><p>For example, for this schema:</p><pre><code class="language-none">namespace example;

table SimpleType {
  x: int = 1;
}

root_type SimpleType;</code></pre><p>the code generated by <code>flatc</code> looks like this:</p><pre><code class="language-julia">module Example

using FlatBuffers
@with_kw mutable struct SimpleType
    x::Int32 = 1
end

# ... other generated stuff
end</code></pre><p>If you don&#39;t want to write a schema, you can pepper your existing Julia types with these macros and then call the functions below to produce flatbuffer-compatible binaries.</p><h4><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h4><p><code>FlatBuffers</code> provides the following functions for reading and writing flatbuffers:</p><pre><code class="language-none">FlatBuffers.serialize(stream::IO, value::T) 
FlatBuffers.deserialize(stream::IO, ::Type{T})</code></pre><p>These methods are not exported to avoid naming clashes with the <code>Serialization</code> module. For convenience, there are also two additional constructors defined for each generated type:     * <code>T(buf::AbstractVector{UInt8}, pos::Integer=0)</code>     * <code>T(io::IO)</code> Here is an example showing how to use them to serialize the example type above.</p><pre><code class="language-julia">import FlatBuffers, Example

# create an instance of our type
val = Example.SimpleType(2)

# serialize it to example.bin
open(&quot;example.bin&quot;, &quot;w&quot;) do f FlatBuffers.serialize(f, val) end

# read the value back again from file
val2 = open(&quot;example.bin&quot;, &quot;r&quot;) do f Example.SimpleType(f) end</code></pre><p>In addition, this package provides the following types and methods, which are useful when inspecting and constructing flatbuffers:</p><ul><li><code>FlatBuffers.Table{T}</code>: type for deserializing a Julia type <code>T</code> from a flatbuffer</li><li><code>FlatBuffers.Builder{T}</code>: type for serializing a Julia type <code>T</code> to a flatbuffer</li><li><code>FlatBuffers.read</code>: performs the actual deserializing on a <code>FlatBuffer.Table</code></li><li><code>FlatBuffers.build!</code>: performs the actual serializing on a <code>FlatBuffer.Builder</code></li></ul><h4><a class="nav-anchor" id="Methods-for-Generated-Types-1" href="#Methods-for-Generated-Types-1">Methods for Generated Types</a></h4><p>For a generated type <code>T</code>, in addition to the constructors mentioned above:</p><ul><li>if <code>T</code> has default values, constructors will be defined as per the <code>@with_kw</code> macro in <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a></li><li><code>FlatBuffers.file_extension(T)</code>: returns the <code>file_extension</code> specified in the schema (if any)</li><li><code>FlatBuffers.file_identifier(T)</code>: returns the <code>file_identifier</code> specified in the schema (if any)</li><li><code>FlatBuffers.has_identifier(T, bytes)</code>: returns whether the given bytes contain the identifier for <code>T</code> at the offset designated by the flatbuffers specification</li><li><code>FlatBuffers.slot_offsets(T)</code>: an array containing the positions of the slots in the vtable for type <code>T</code>, accounting for gaps caused by deprecated fields</li><li><code>FlatBuffers.root_type(T)</code>: returns whether the type is designated as the root type by the schema. Also note however that no <code>root_type</code> definition is necessary in Julia; any of the generated <code>mutable struct</code>s can be a valid root table type.</li></ul><h4><a class="nav-anchor" id="Circular-References-1" href="#Circular-References-1">Circular References</a></h4><p>It&#39;s a bit unfortunate that the flatbuffers example uses mutually referential types, something which Julia doesn&#39;t have support for yet. However, there is a <a href="https://github.com/JuliaLang/julia/issues/269#issuecomment-68421745">workaround</a> - by modifying the code generated by <code>flatc</code> slightly to add a type parameter, we can refer to a type that hasn&#39;t yet been defined.</p><pre><code class="language-none">FlatBuffers.@with_kw mutable struct Monster{T}
    # ...
    test::T = nothing
    # ...
end</code></pre><p>In general though, try to avoid schemas which introduce these kinds of circular references. For the full <code>Monster</code> example see the test suite <a href="https://github.com/dmbates/FlatBuffers.jl/tree/master/test">here</a>.</p><h4><a class="nav-anchor" id="Internal-Utilities-1" href="#Internal-Utilities-1">Internal Utilities</a></h4><p>These functions are used by the code generated by <code>flatc</code>. Documentation is also included for many internal methods and may be queried using <code>?</code> at the REPL.</p><ul><li><code>@ALIGN T size_in_bytes</code>: convenience macro for forcing a flatbuffer alignment on the Julia type <code>T</code> to <code>size_in_bytes</code></li><li><code>@with_kw mutable struct T fields...</code>: convenience macro for defining default field values for Julia type <code>T</code></li><li><code>@UNION T Union{T1,T2,...}</code>: convenience macro for defining a flatbuffer union type <code>T</code></li><li><code>@STRUCT struct T fields... end</code>: convenience macro for defining flatbuffer struct types, ensuring any necessary padding gets added to the type definition</li></ul><footer><hr/></footer></article></body></html>
